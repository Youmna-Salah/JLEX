import java.lang.System;
import java.io.*;
import java.util.Stack;

class Lexer {

	Yylex tokenizer;
	boolean end = false;
	public  Lexer(String fileName) 
	{
	  try
	  {
	  tokenizer=new Yylex(new BufferedReader(new FileReader(fileName)));
	  }
	  catch(Exception e)
	  {
	  
	  }	 
	}
	public Token nextToken()
	{
		Token next=null;
		try
		{
			//if(!end) {
				 next=  tokenizer.getToken();
				 if(next.getTokenType() == 48) {
			 		end = true;
			 	}		
			//}
		 
		}
		catch(Exception e)
		{
		}
		return next;
	}
	}


%%


%function getToken
%type Token
%char
%line


%{
	//initialize  variables to be used by class
	private Stack<Character> stack_char = new Stack<Character>();
	boolean paran = false;
	boolean square = false;
	boolean curly = false;
%}


%init{

//Add code to be executed on initialization of the lexer
%init}
STRING_LIT =\"(.)+\"|\`[0-9]*[A-Za-z]*[0-9]*\`
IMPORT =import SPACE STRING_LIT BREAKLINE
PACKAGE =package SPACE IDENTIFIER BREAKLINE
SPACE =[\n\ \t\b\012]
BREAKLINE =\n
FUNC=func
CONST=const
EQUAL=[\=]
PLUS =\+
MINUS =\-
VAR=var
IF =if
ASTRISK =\*
COLON_EQUAL = \:=
ELSE =else
PERCENT =\%
AND_OP =\&&
REL_OP = \<|\>|\==
RETURN =return
COLON = \:
SEMI_COLON = \;
OPEN_PARAN=\( EXP CLOSE_PARAN
CLOSE_PARAN =\) 
OPEN_SQUARE =\[ 
CLOSE_SQUARE =\] 
EXP =?IDENTIFIER ?DOT ?COMMA ?INT_LIT ?SLASH ?STRING_LIT
IDENTIFIER=[A-Za-z]+[0-9]*
ANY =[0-9]|[A-Za-z]|COLON|SEMI_COLON|DOT|INT_LIT|OPEN_SQUARE|OPEN_CURLY|OPEN_PARAN|CLOSE_CURLY|OPEN_PARAN|CLOSE_CURLY|CLOSE_SQUARE|CLOSE_PARAN|PLUS|MINUS|COMMA|SLASH
OPEN_CURLY=\{
CLOSE_CURLY=\}
DOT=\.
COMMA=\,
INT_LIT=[0-9]+
SLASH=/

%eofval{
//Add code to be executed when the end of the file is reached
	{
		if(paran) {
			return (new Token(Token.EOF, "There is some ( that is not closed"));
		}
		if(square) {
			return (new Token(Token.EOF, "There is some [ that is not closed"));
		}
		if(curly) {
			return (new Token(Token.EOF, "There is some {} that is not closed"));
		}
		return (new Token(Token.EOF,"Done"));
	}
%eofval}


%% 
<YYINITIAL> {STRING_LIT} { return (new Token(Token.STRING_LIT,yytext()));}
<YYINITIAL> {PACKAGE} { return (new Token(Token.PACKAGE,yytext()));}
<YYINITIAL> {SPACE} {}
<YYINITIAL> {BREAKLINE} {}
<YYINITIAL> {REL_OP} { return (new Token(Token.REL_OP,yytext()));}
<YYINITIAL> {PLUS} { return (new Token(Token.PLUS,yytext()));}
<YYINITIAL> {MINUS} { return (new Token(Token.MINUS,yytext()));}
<YYINITIAL> {ASTRISK} { return (new Token(Token.ASTRISK,yytext()));}
<YYINITIAL> {RETURN} { return (new Token(Token.RETURN,yytext()));}
<YYINITIAL> {IMPORT} { return (new Token(Token.IMPORT,yytext()));}
<YYINITIAL> {ELSE} { return (new Token(Token.ELSE,yytext()));}
<YYINITIAL> {IF} { return (new Token(Token.IF,yytext()));}
<YYINITIAL> {COLON} { return (new Token(Token.COLON,yytext()));}
<YYINITIAL> {COLON_EQUAL} { return (new Token(Token.COLON_EQUAL,yytext()));}
<YYINITIAL> {SEMI_COLON} { return (new Token(Token.SEMI_COLON,yytext()));}
<YYINITIAL> {AND_OP} { return (new Token(Token.AND_OP,yytext()));}
<YYINITIAL> {PERCENT} { return (new Token(Token.PERCENT,yytext()));}
<YYINITIAL> {FUNC} { return (new Token(Token.FUNC,yytext()));}
<YYINITIAL> {COMMA} { return (new Token(Token.COMMA,yytext()));}
<YYINITIAL> {CONST} { return (new Token(Token.CONST,yytext()));}
<YYINITIAL> {EQUAL} { return (new Token(Token.EQUAL,yytext()));}
<YYINITIAL> {VAR} { return (new Token(Token.VAR,yytext()));}
<YYINITIAL> {IDENTIFIER} { return (new Token(Token.IDENTIFIER,yytext()));}
<YYINITIAL> {OPEN_PARAN} { stack_char.push('('); return (new Token(Token.OPEN_PARAN,yytext()));}
<YYINITIAL> {OPEN_SQUARE} { stack_char.push('[');return (new Token(Token.OPEN_SQUARE,yytext()));}
<YYINITIAL> {OPEN_CURLY} { stack_char.push('{');return (new Token(Token.OPEN_CURLY,yytext()));}
<YYINITIAL> {CLOSE_PARAN} { 
		Character temp = stack_char.pop();
		if(temp == '(') {
			return (new Token(Token.CLOSE_PARAN,yytext()));
		} else {
			if(temp =='[') {
				square = true;
			}
			if(temp == '{') {
				curly = true;
			}
			return (new Token(Token.ERROR, "You have a missing bracket"));
		}
	}
<YYINITIAL> {CLOSE_SQUARE} { 
		Character temp = stack_char.pop();
			if(temp == '[') {
				return (new Token(Token.CLOSE_SQUARE,yytext()));
			} else {
				if(temp == '(') {
					paran = true;
				}
				if(temp == '{') {
					curly = true;
				}
				return ( new Token(Token.ERROR, "You have a missing bracket"));
			}

		}
<YYINITIAL> {CLOSE_CURLY} { 
		Character temp = stack_char.pop();
		if(temp == '{') {
			return (new Token(Token.CLOSE_CURLY,yytext()));
		} else {
			if(temp =='[') {
				square = true;
			}
			if(temp == '(') {
				paran = true;
			}
			return (new Token(Token.ERROR, "You have a missing bracket in line " + (yyline+1) ));
		}
	}
<YYINITIAL> {DOT} { return (new Token(Token.DOT,yytext()));}
<YYINITIAL> {INT_LIT} { return (new Token(Token.INT_LIT,yytext()));}
<YYINITIAL> {SLASH} { return (new Token(Token.SLASH,yytext()));}
<YYINITIAL> . {
  return new Token(Token.ERROR, "Invalid input: " + yytext());
}
